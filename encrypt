#!/bin/bash
# encrypts all files in the specified directory 'indir' 
# writes keys into file 'key' 
# writes encrypted binary files with the same names into directory 'outdir'

PROGN=${0##*/}
COMPRESSOR=lzma	# the default compression program
EXT=lz			# and the extension that goes with it

# function to compress and encrypt one file
# takes four arguments: ITEM INDIR KEYDIR OUTDIR
# KEYDIR OUTDIR must be writeable
# creates and cleans up two temporary files in OUTDIR
function processfile {

	local INFILE=$1 
	local OUTFILE=$2
	local EX="${1##*.}" # this file's extension
	EX=${EX,,} # convert to lower case for ease of detecting either

	# if EX passes one of these tests, then avoid all compression 
	[ "$EX" = 'jpg' ] || [ "$EX" = 'jpeg' ] || [ "$EX" = 'mp4' ] || [ "$EX" = 'zip' ] || [ "$EX" = '7z' ] || \
	[ "$EX" = 'lz' ] || [ "$EX" = 'zst' ] || [ "$EX" = 'gz' ] || [ "$EX" = 'bz2' ] || {

    	[ $HEXTEST ] && {
   			hexcheck $INFILE $OUTFILE.hex 2>/dev/null # ignore failure messages
   			if [ "$?" -eq 0 ]; then	# status of hexcheck when INFILE is entirely hexadecimal
				OUTFILE=$OUTFILE.hex
				INFILE="$OUTFILE"
   			else rm $OUTFILE.hex
			fi
		}

		[ $B64TEST ] && [ "$OUTFILE" = "$2" ] && { #  not already hexed
   			base64 -d -w 0 $INFILE > $OUTFILE.b64 2>/dev/null # turns base64 into binary, saving 25%
   			if [ "$?" -eq 0 ]; then	# status of base64 when INFILE was entirely in base64
				OUTFILE=$OUTFILE.b64
				INFILE="$OUTFILE"
			else rm $OUTFILE.b64
   			fi 
		}
	
		# regardless whether hexcheck or base64 tests succeeded or not, apply general compression test	
		$COMPRESSOR $FLAGS $INFILE > $OUTFILE.$EXT 
		local CMPS=$( stat -c%s $OUTFILE.$EXT ) # the size after compression
		local ORGS=$( stat -c%s $INFILE )  # and before compression
		# use compressed version only if it is actually smaller
		if [ "$CMPS" -lt "$ORGS" ]; then
			# clean up outfile if it exists
			if [ -e "$OUTFILE" ]; then rm $OUTFILE; fi 
			OUTFILE=$OUTFILE.$EXT  # assign the better compressed file name
			INFILE=$OUTFILE # make the final compressed file to be the infile
		else # clean up and stay with the previous infile
			rm $OUTFILE.$EXT	
		fi
	}
	# generate the key of the same size as the infile,
	# encrypt with it and write to final OUTFILE 
	# append the key to the global linear keyfile
	if [ "$INFILE" = "$OUTFILE" ]; then
		keygen $INFILE | tee -a "$KEYFILE" | symcrypt $INFILE > $OUTFILE.tmp
		mv $OUTFILE.tmp $OUTFILE
	else
		keygen $INFILE | tee -a "$KEYFILE" | symcrypt $INFILE > $OUTFILE
	fi

} # end of processfile

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {

	[ -z "$2" ] && { 
		printf "$PROGN processdir: outdir not given!\n" >&2
		exit 2
	}
	[ -e "$2" ] && { 
		printf "$PROGN processdir: outdir '$2' already exists!\n" >&2
		exit 2
	}

	# create the ouput directory
	mkdir $2 || {
		printf "$PROGN quitting, failed to create output directory '$2'!\n" >&2
		exit 2
	}

	# list indir contents in standard order
	local ITEMS=$(ls -AL $1)

	# iterate through the listing
	for ITEM in $ITEMS; do
		local IND=$1/$ITEM # append $ITEM to $INDIR path
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				processdir $IND $2/$ITEM 
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] || continue # only process genuine file now
   		processfile $IND $2/$ITEM  
	done
} # end of processdir

# function to update a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function updatedir {

	[ -d "$2" ] || {
		printf "$PROGN updatedir: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN updatedir: output dir $3 is invalid\n" >&2
		exit 2
	}

	# sort files in INDIR by size
	# stripping the path path prior to using ls was done thus: FILEND=${INFILE##*/} 
	local ITEMS=$(ls -AL $1)  # $(ls -SAL $1)
	# iterate through the listing checking for newer items
	for ITEM in $ITEMS; do
		local ID=$1/$ITEM # append $ITEM to $INDIR path
		local OD=$3/$ITEM # and corresponding $outdir path

   		if [ -d "$ID" ]; then  # process existing subdirectory?
			if [ -n "$RECURSE" ]; then # but only when recursing
				[ -d "$OD" ] || { # here matching dir does not exist
					printf " A: $ID\n" # so add it
					# just push ITEM onto paths 
					processdir $ID $2/$ITEM $OD & #$BJ
					continue
				}
				# test the dirs modification times
				# note that -nt only works for additions/deletions to dirs			
				if [ $(stat -c%Y $ID) -gt $(stat -c%Y $OD) ]; then 
					printf " U: $ID\n" # so update it
					updatedir $ID $2/$ITEM $OD & #$BJ
					continue
				fi
				continue # up to date dir
			fi
			continue # not recursing, ignore this subdir 
		fi
   		[ -f "$ID" ] || continue # only process genuine files now 
		[ -e "$OD" ] || { # here $OD file does not exist
			printf "   a: $ID\n" # so add it
			processfile $ID $OD &  
			continue
		}
		if [ "$ID" -nt "$OD" ]; then  # here the input file is newer 
			printf "   u: $ID\n" # so update it
   			processfile $ID $OD &  
		fi # else just skip it
	done
} # end of updatedir

# function to clean up a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function cleandir {

	[ -d "$1" ] || {
		printf "$PROGN clean: input dir $1 is invalid\n" >&2
		exit 2
	}
	[ -d "$2" ] || {
		printf "$PROGN clean: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN clean: output dir $3 is invalid\n" >&2
		exit 2
	}

	# list all items in standard order
	local ITEMS=$(ls -AL $3)
	# iterate through the list checking for missing items
	for ITEM in $ITEMS; do
		local ID=$1/$ITEM # append $ITEM to $INDIR path
		local KD=$2/$ITEM # append $ITEM to $KEYDIR path
		local OD=$3/$ITEM # and the examined $OUTDIR path

   		if [ -d "$OD" ]; then  # process existing subdirectory?
			if [ -n "$RECURSE" ]; then # but only when recursing
				[ -d "$ID" ] || { # here matching $INDIR dir does not exist
					printf " D: $OD $KD\n" # so remove it 
					rm -rf $OD $KD &
					continue
				}			
				cleandir $ID $KD $OD &  # otherwise recurse
			fi
			continue # not recursing, ignore this subdir 
		fi
   		[ -f "$OD" ] || continue # only process genuine files now 
		[ -e "$ID" ] || { # here $ID file does not exist
			printf "   d: $OD $KD.*\n" # so delete them
			rm $OD $KD.* 
			continue
		}
	done
} # end of cleandir

function usage { printf "Usage: $PROGN [-h][-b][-x][-q][-r][-v][-z] indir keydir outdir\n" >&2; }

function helpmsg {
	usage
	printf "\t%s\n" \
		'-b | --b64 : test for base64 encoded files' \
		'-c | --cleanup : do deletions in the archive' \
		'-h | --help : print this text' \
		'-q | --quiet : turn off the final summary' \
		'-r | --recurse : process also subdirectories' \
		'-u | --update : update' \
		'-v | --verbose : detailed reporting' \
		'-x | --hex : test for hexadecimal files' \
		'-z | --zstd : use zstd compression instead of lzma' >&2
	exit 1
}
# Main starts here
# get options, including long options, extracted as arg to the last option '-'
while getopts hbcxqruvz-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
	b | b64 ) B64TEST=0;;
	c | clean ) CLEAN=0;; 
	h | help ) helpmsg;;
	q | quiet ) QUIET=0;;
	r | recurse ) RECURSE=0;;
	u | update ) UPDATE=0;;
	v | verbose ) VERBOSE=0;; 
	x | hex ) HEXTEST=0;;
  	z | zstd ) COMPRESSOR=zstd; EXT=zst;; #alternative compressor and its extension
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

# Globally validate the input directory
[ -d "$1" ] || { 
	printf "$PROGN quitting, input directory $1 not found\n" >&2
	exit 2
}

# Globally validate the -c option and keyfile
if [ -z "$UPDATE" ]; then
	[ -z "$CLEAN" ] || { 
		printf "$PROGN create failed: option -c only makes sense with -u\n" >&2
		exit 2
	}
	[ -e "$2" ] && {
		printf "$PROGN create failed: keyfile '$2' already exists\n" >&2
		exit 2
	}
else
	[ -f "$2" ] || {
		printf "$PROGN update failed: keyfile '$2' not found\n" >&2
		exit 2
	}
fi
# Set verified global key file
KEYFILE=$2

# Globally validate the compressor. It has been set either to lzma or zstd
[ -z $( which "$COMPRESSOR" ) ] && { 
	printf "$PROGN quitting, compressor utility $COMPRESSOR not found\n" >&2
	exit 2
}

# Global options for the compressor
FLAGS='-c -z -q' 
if [ $VERBOSE ]; then 
	if [ "$COMPRESSOR" = 'lzma' ]; then FLAGS='-c -z -v';	else FLAGS='-c'; fi
fi

if [ $UPDATE ]; then 
	printf "$PROGN: updating archive $3, using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	updatedir $1 $2 $3
else
	printf "$PROGN: compressing and encrypting $1, using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	processdir $1 $3
fi
wait # for all sub proccesses to finish
if [ $CLEAN ]; then 
	printf "$PROGN: cleaning up archive $3\n" 
	cleandir $1 $2 $3
fi
wait # for all sub proccesses to finish

# optional final report
if [ ! $QUIET ]; then
	SIZES=( $( du -bs $3 $1 ) ) # array of size,dir,size,
	let SIZES[0]-=4096 # subtract the size of the top directory files
	let SIZES[2]-=4096 # as they are not actual data
	printf "$PROGN: ${SIZES[3]} ${SIZES[2]} => ${SIZES[1]} ${SIZES[0]} "
	if [ ${SIZES[0]} = ${SIZES[2]} ]; then 
		printf "(100 %%)\n"
	else
		CR=$(( (5+100000*${SIZES[0]}/${SIZES[2]})/10 )) # calculate percentage rounded to two d.p.	
		printf "(${CR: 0:2}.${CR: 2:4} %%)\n" # compression ratio printed as xx.xx%
	fi 
	printf "$PROGN: keys are in $2\n"
fi
