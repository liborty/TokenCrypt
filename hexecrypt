#!/bin/bash
# hexadecimal encryption
# hexecrypt encrypts all *.hex files in the current directory, such as various
# internet security tokens, into corresponding encrypted binary files *.scr
# takes one binary keyfile argument, e.g. keyfile.key (to be kept secure)
# if the argument and ./keyfile.key are both missing, 
# new keyfile will be generated in the current directory

# also keygen can generate a keyfile of a suitable length for any given file
# and binkeygen generates manually a key of any given length

# to hex encode any file, use: 'xxd -p file > hexfile'
# to revert back: 'xxd -p -r hexfile > file'

HEXFILE=$( ls -1 *.hex 2>/dev/null | head -n 1 )
if [ -z "$HEXFILE" ]; then
	printf "${0##*/} quitting, no .hex file here in $(pwd)\n" 1>&2
	exit 2
fi

case $# in
	0)
		KEYFILE=${HEXFILE%.hex}.key
		if ! [ -f "$KEYFILE" ]; then 
			keygen $HEXFILE > $KEYFILE
			printf "${0##*/} generated keyfile '$KEYFILE' of %d bytes, use it for decrypting\n" \
							$( stat -c%s $KEYFILE ) 1>&2
		fi;; 
	1)
		KEYFILE=$1
        if ! [ -f "$KEYFILE" ]; then
			printf "${0##*/}: quitting, keyfile '$KEYFILE' not found\n" 1>&2
			exit 2
		fi;;
	*) 
		printf "${0##*/} quitting, too many arguments, takes none or one keyfile argument\n" 1>&2 
		exit 2;;
esac

for FILE in ./*.hex; do
    [ -f "$FILE" ] || continue
    let COUNT+=1
    xxd -p -r $FILE | symcrypt $KEYFILE > ${FILE%.hex}.scr
done
printf "${0##*/} encrypted $COUNT files\n" 1>&2
