#!/bin/bash
# decrypts all files in the specified readable file 'infile' 
# reads keys from keysfile 
# writes restored, decompressed and decrypted files into writeable directory 'outdir' 

PROGN=${0##*/}

# processfile will decompress and decrypt one file
# it expects two arguments: INFILE OUTFILE
# and it reads from fd 3 which is an open for reading KEYFILE
function processfile {

	local INFILE=$1 
	local OUTFILE=$2
	local FSIZE=`stat -c%s $INFILE`
	local CH=`head -c 1 <&3` # read the compression encoding char
	case "$CH" in
	# u (uncomressed) can be for a listed extension, or because all compressions have failed
	u ) head -c $FSIZE <&3 | symcrypt $INFILE > $OUTFILE; return;;
	h ) head -c $FSIZE <&3 | symcrypt $INFILE | hexify > $OUTFILE; return;;
	b ) head -c $FSIZE <&3 | symcrypt $INFILE | base64 -w 0 > $OUTFILE; return;;
	i ) head -c $FSIZE <&3 | symcrypt $INFILE | lzma -d > $OUTFILE; return;;
	j ) head -c $FSIZE <&3 | symcrypt $INFILE | lzma -d | hexify > $OUTFILE; return;;
	k ) head -c $FSIZE <&3 | symcrypt $INFILE | lzma -d | base64 -w 0 > $OUTFILE; return;;
	l ) head -c $FSIZE <&3 | symcrypt $INFILE | zstd -d -c > $OUTFILE; return;;
	m ) head -c $FSIZE <&3 | symcrypt $INFILE | zstd -d -c | hexify > $OUTFILE; return;;
	n ) head -c $FSIZE <&3 | symcrypt $INFILE | zstd -d -c | base64 -w 0 > $OUTFILE; return;;
	* ) printf "$PROGN processfile: unrecognised ch\n"; exit 2;;
	esac
}

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {

	# create the ouput directory 
	mkdir $2 || {
		printf "$PROGN processdir: failed to create output directory '$2'!\n" >&2
		exit 2
	}
	local ITEMS=$(ls -AL $1)
	# iterate through the listing
	for ITEM in $ITEMS; do
		local IND=$1/$ITEM
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				processdir $IND $2/$ITEM
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] || continue # only process genuine file now
   		processfile $IND $2/$ITEM 
	done
} # end of processdir

function usage { printf "Usage: $PROGN [-h][-q][-r][-v] indir keyfile outdir\n" >&2; }

# Main starts here
# get options, including long options, extracted as arg to the last option '-'
while getopts hqrv-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
    h | help ) usage; printf "\t%s\n" \
	'-h | --help : print this text' \
	'-q | --quiet : turn off the final summary' \
	'-r | --recurse : process also subdirectories' \
	'-v | --verbose : detailed reporting' 	
	exit 1;;
	# record all presented options
	q | quiet ) QUIET=0;;
	r | recurse ) RECURSE=0;;
	v | verbose ) VERBOSE=0;;  
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove already parsed options and args from $@ list

# Globally validate the input file
[ -f "$1" ] || { 
	printf "$PROGN: input file '$1' not found\n" >&2
	exit 2
}
# Globally validate the keyfile
[ -f "$2" ] || { 
	printf "$PROGN: key file '$2' not found\n" >&2
	exit 2
}
# Globally open the keyfile
exec 3<$2 || {
	printf "$PROGN: key file '$2' failed to open for reading\n" >&2
	exit 2	
}
# Globally validate the output directory
[ -n "$3" ] || { 
	printf "$PROGN: outdir arg missing\n" >&2
	exit 2
}
[ -e "$3" ] && { 
	printf "$PROGN: output directory '$3' already exists!\n" >&2
	exit 2
}

# Warn about missing decompressors
if [ -z $( which zstd ) ]; then 
	printf "$PROGN warning, zstd compressor is not installed, will not decompress .zst files\n" >&2
fi
if [ -z $( which lzma ) ]; then 
	printf "$PROGN warning, lzma compressor is not installed, will not decompress .lz files\n" >&2
fi
if [ -z $( which base64 ) ]; then 
	printf "$PROGN warning, base64 decoder is not installed, will not unpack .b64 files\n" >&2
fi
if [ -z $( which hexify ) ]; then 
	printf "$PROGN warning, hexify is not installed, will not unpack .hex files\n" >&2
fi

tar -xpJf $1 $1dir # $1dir is temporary encrypted dir unpacked
printf "$PROGN: decrypting and decompressing\n" 
processdir $1dir $3
rm -rf $1dir

# optional final report
if ! [ $QUIET ]; then
	SIZES=( $( du -hbs $3 $1 ) ) # array of size,dir,size,dir
	# let SIZES[0]-=4096 # subtract the size of the top directory files
	# let SIZES[2]-=4096 # as they are not actual data
	printf "$PROGN: ${SIZES[3]} ${SIZES[2]} "
	if [ ${SIZES[0]} = ${SIZES[2]} ]; then printf "(100 %%) => ${SIZES[1]} ${SIZES[0]}\n"; else
		CR=$(( (5+100000*${SIZES[2]}/${SIZES[0]})/10 )) # calculate percentage rounded to two d.p.	
		printf "(${CR: 0:2}.${CR: 2:4} %%) => ${SIZES[1]}: ${SIZES[0]}\n"
	fi
	# compressed size x 10^5, printed as xx.xx% 
	printf "$PROGN: decrypted $1 into $3\n" >&2
fi
