#!/bin/bash
# encrypts all files in the specified directory 'indir' 
# writes key files into directory 'keydir', extensions indicating compression methods 
# writes encrypted binary files with the same names into directory 'outdir' 

PROGN=${0##*/}
COMPRESSOR=lzma	# the default compression program
EXT=lz				# and the extension that goes with it
BACKSZ=10000 # size of files to be encrypted in the subshells

# function to compress and encrypt one file
# takes four arguments: ITEM INDIR KEYDIR OUTDIR
# KEYDIR OUTDIR must be writeable
# creates and cleans up two temporary files in OUTDIR
function processfile {

	local INFILE=$1 
	local KEYFILE=$2
	local OUTFILE=$3
	local EX="${1##*.}" # this file's extension
	EX=${EX,,} # convert to lower case for ease of detecting either

	# if EX passes one of these tests, then avoid all compression 
	[ "$EX" = 'jpg' ] || [ "$EX" = 'mp4' ] || [ "$EX" = 'zip' ] || [ "$EX" = '7z' ] || \
	[ "$EX" = 'lz' ] || [ "$EX" = 'zst' ] || [ "$EX" = 'gz' ] || [ "$EX" = 'bz2' ] || {

    	[ $HEXTEST ] && {
   			hexcheck $INFILE $OUTFILE.tmp000 2>/dev/null # ignore failure messages
   			if [ "$?" -eq 0 ]; then	# status of hexcheck when INFILE is entirely hexadecimal
				INFILE="$OUTFILE".tmp000 # now this becomes the binary file to further compress
				KEYFILE="$KEYFILE".hex # append .hex extension for hexadecimal origin
   			fi
		}

		[ $B64TEST ] && [ "$INFILE" = "$1" ] && { #  still the original input file?
   			base64 -d -w 0 $INFILE > $OUTFILE.tmp000 2>/dev/null # turns base64 into binary, saving 25%
   			if [ "$?" -eq 0 ]; then	# status of base64 when INFILE was entirely in base64
				INFILE="$OUTFILE".tmp000 # now this becomes the binary file to further compress
				KEYFILE="$KEYFILE".b64 # append .b64 extension for base64 origin
   			fi 
		}
	
		# regardless whether hexcheck or base64 tests succeeded or not, test general compression	
		$COMPRESSOR $FLAGS $INFILE > $OUTFILE.tmp001 
		local CMPS=$( stat -c%s $OUTFILE.tmp001 ) # the size after compression
		local ORGS=$( stat -c%s $INFILE )  # and before compression
		# use compressed version only if it is actually smaller
		if [ "$CMPS" -lt "$ORGS" ]; then 
			KEYFILE="$KEYFILE".$EXT # append compression extension to the keyfile to be generated
			INFILE="$OUTFILE".tmp001  # assign the compressed file name, else stay with previous
		fi
	}
	# generate and write out the key of the same size as the infile
	keygen $INFILE > $KEYFILE
	# encrypt with it and write to OUTFILE 
	symcrypt $INFILE $KEYFILE $OUTFILE &
	rm $OUTFILE.tmp000 $OUTFILE.tmp001 2> /dev/null  #tidy up if needed
}

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {

	[ -z "$2" ] && { 
		printf "$PROGN processdir: keydir not given!\n" >&2
		exit 2
	}
	[ -e "$2" ] && { 
		printf "$PROGN processdir: keydir $2 already exists!\n" >&2
		exit 2
	}
	[ -z "$3" ] && { 
		printf "$PROGN processdir: outdir not given!\n" >&2
		exit 2
	}
	[ -e "$3" ] && { 
		printf "$PROGN processdir: outdir $3 already exists!\n" >&2
		exit 2
	}

	# create the ouput directories
	mkdir $2 $3
	[ "$?" -ne 0 ] && {
		printf "$PROGN quitting, failed to create output directories $2 $3!\n" >&2
		exit 2
	}

	# sort files in INDIR by size
	# stripping the path path prior to using ls was done thus: FILEND=${INFILE##*/} 
	local ITEMS=$(ls -AL $1)		#$(ls -SAL $1)
	# prepare to fire off subshells
	# local BJ=\&

	# iterate through the listing
	for ITEM in $ITEMS; do
		local IND=$1/$ITEM # append $ITEM to $INDIR path
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				processdir $IND $2/$ITEM $3/$ITEM &
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] || continue # only process genuine file now
 		# turn off subshells when file size falls below BACKSZ
   		# [ -z "$BJ" ] || [ $( stat -c%s $IND ) -ge $BACKSZ ] || BJ='' 
   		processfile $IND $2/$ITEM $3/$ITEM & #$BJ 
	done
} # end of processdir

# function to update a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function updatedir {

	[ -d "$2" ] || {
		printf "$PROGN updatedir: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN updatedir: output dir $3 is invalid\n" >&2
		exit 2
	}

	# sort files in INDIR by size
	# stripping the path path prior to using ls was done thus: FILEND=${INFILE##*/} 
	local ITEMS=$(ls -AL $1)  # $(ls -SAL $1)
	# prepare to fire off subshells
	# local BJ=\&
	# iterate through the listing checking for newer items
	for ITEM in $ITEMS; do
		local ID=$1/$ITEM # append $ITEM to $INDIR path
		local OD=$3/$ITEM # and corresponding $outdir path

   		if [ -d "$ID" ]; then  # process existing subdirectory?
			if [ -n "$RECURSE" ]; then # but only when recursing
				[ -d "$OD" ] || { # here matching dir does not exist
					printf " A: $ID\n" # so add it
					# just push ITEM onto paths 
					processdir $ID $2/$ITEM $OD & #$BJ
					continue
				}
				# test the dirs modification times
				# note that -nt only works for additions/deletions to dirs			
				if [ $(stat -c%Y $ID) -gt $(stat -c%Y $OD) ]; then 
					printf " U: $ID\n" # so update it
					updatedir $ID $2/$ITEM $OD & #$BJ
					continue
				fi
				continue # up to date dir
			fi
			continue # not recursing, ignore this subdir 
		fi
   		[ -f "$ID" ] || continue # only process genuine files now
 		# turn off subshells when file size falls below BACKSZ
   		# [ -z "$BJ" ] || [ $( stat -c%s $ID ) -ge $BACKSZ ] || BJ='' 
		[ -e "$OD" ] || { # here $OD file does not exist
			printf "   a: $ID\n" # so add it
			processfile $ID $2/$ITEM $OD & #$BJ 
			continue
		}
		if [ "$ID" -nt "$OD" ]; then  # here the input file is newer 
			printf "   u: $ID\n" # so update it
   			processfile $ID $2/$ITEM $OD & #$BJ 
		fi # else just skip it
	done
} # end of updatedir

# function to clean up a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function cleandir {

	[ -d "$1" ] || {
		printf "$PROGN clean: input dir $1 is invalid\n" >&2
		exit 2
	}
	[ -d "$2" ] || {
		printf "$PROGN clean: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN clean: output dir $3 is invalid\n" >&2
		exit 2
	}

	# list all items in standard order
	local ITEMS=$(ls -AL $3)
	# iterate through the list checking for missing items
	for ITEM in $ITEMS; do
		local ID=$1/$ITEM # append $ITEM to $INDIR path
		local KD=$2/$ITEM # append $ITEM to $KEYDIR path
		local OD=$3/$ITEM # and the examined $OUTDIR path

   		if [ -d "$OD" ]; then  # process existing subdirectory?
			if [ -n "$RECURSE" ]; then # but only when recursing
				[ -d "$ID" ] || { # here matching $INDIR dir does not exist
					printf " D: $OD $KD\n" # so remove it 
					rm -rf $OD $KD &
					continue
				}			
				cleandir $ID $KD $OD &  # otherwise recurse
			fi
			continue # not recursing, ignore this subdir 
		fi
   		[ -f "$OD" ] || continue # only process genuine files now 
		[ -e "$ID" ] || { # here $ID file does not exist
			printf "   d: $OD $KD.*\n" # so delete them
			rm $OD $KD.* 
			continue
		}
	done
} # end of cleandir

function usage { printf "Usage: $PROGN [-h][-b][-x][-q][-r][-v][-z] indir keydir outdir\n" >&2; }

function helpmsg {
	usage
	printf "\t%s\n" \
		'-b | --b64 : test for base64 encoded files' \
		'-c | --cleanup : do deletions in the archive' \
		'-h | --help : print this text' \
		'-q | --quiet : turn off the final summary' \
		'-r | --recurse : process also subdirectories' \
		'-u | --update : update' \
		'-v | --verbose : detailed reporting' \
		'-x | --hex : test for hexadecimal files' \
		'-z | --zstd : use zstd compression instead of lzma' >&2
	exit 1
}
# Main starts here
# get options, including long options, extracted as arg to the last option '-'
while getopts hbcxqruvz-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
	b | b64 ) B64TEST=0;;
	c | clean ) CLEAN=0;; 
	h | help ) helpmsg;;
	q | quiet ) QUIET=0;;
	r | recurse ) RECURSE=0;;
	u | update ) UPDATE=0;;
	v | verbose ) VERBOSE=0;; 
	x | hex ) HEXTEST=0;;
  	z | zstd ) COMPRESSOR=zstd; EXT=zst;; #alternative compressor and its extension
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

# Globally validate the input directory
[ -d "$1" ] || { 
	printf "$PROGN quitting, input directory $1 not found\n" >&2
	exit 2
}

# Globally validate the compressor. It has been set either to lzma or zstd
[ -z $( which "$COMPRESSOR" ) ] && { 
	printf "$PROGN quitting, compressor utility $COMPRESSOR not found\n" >&2
	exit 2
}

FLAGS='-c -z -q' # the default lags to the compressor
if [ $VERBOSE ]; then 
	if [ "$COMPRESSOR" = 'lzma' ]; then FLAGS='-c -z -v';	else FLAGS='-c'; fi
fi

if [ $UPDATE ]; then 
	printf "$PROGN: updating archive $3, using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	updatedir $1 $2 $3
else
	printf "$PROGN: compressing and encrypting $1, using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	processdir $1 $2 $3
fi
wait # for all sub proccesses to finish
if [ $CLEAN ]; then 
	printf "$PROGN: cleaning up archive $3\n" 
	cleandir $1 $2 $3
fi
wait # for all sub proccesses to finish

# optional final report
if ! [ $QUIET ]; then
	SIZES=( $( du -hbs $3 $1 ) ) # array of size,dir,size,dir
	printf "$PROGN: ${SIZES[3]} ${SIZES[2]} => ${SIZES[1]} ${SIZES[0]} "
	if [ ${SIZES[0]} = ${SIZES[2]} ]; then printf "(100 %%)\n"; else
		CR=$(( (5+100000*${SIZES[0]}/${SIZES[2]})/10 )) # calculate percentage rounded to two d.p.	
		printf "(${CR: 0:2}.${CR: 2:4} %%)\n" # compression ratio printed as xx.xx%
	fi 
	printf "$PROGN: keys are in $2\n"
fi
