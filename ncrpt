#!/bin/bash
# encrypts all files in the specified directory 'indir' 
# writes key files into directory 'keydir', extensions indicating compression methods 
# writes encrypted binary files with the same names into directory 'outdir' 

PROGN=${0##*/}
COMPRESSOR=lzma	# the default compression program
EXT=lz				# and the extension that goes with it
BACKSZ=10000 # size of files to be encrypted in the subshells

# function to compress and encrypt one file
# takes four arguments: ITEM INDIR KEYDIR OUTDIR
# KEYDIR OUTDIR must be writeable
# creates and cleans up two temporary files in OUTDIR
function processfile {

	local INFILE=$2/$1 
	local KEYFILE=$3/$1
	local OUTFILE=$4/$1
	local EX="${1##*.}" # this file's extension
	EX=${EX,,} # convert to lower case for ease of detecting either

	# if EX passes one of these tests, then avoid all compression 
	[ "$EX" = 'jpg' ] || [ "$EX" = 'mp4' ] || [ "$EX" = 'zip' ] || [ "$EX" = '7z' ] || \
	[ "$EX" = 'lz' ] || [ "$EX" = 'zst' ] || [ "$EX" = 'gz' ] || [ "$EX" = 'bz2' ] || {

    	[ $HEXTEST ] && {
   			hexcheck $INFILE $OUTFILE.tmp000 2>/dev/null # ignore failure messages
   			if [ "$?" -eq 0 ]; then	# status of hexcheck when INFILE is entirely hexadecimal
				INFILE="$OUTFILE".tmp000 # now this becomes the binary file to further compress
				KEYFILE="$KEYFILE".hex # append .hex extension for hexadecimal origin
   			fi
		}

		[ $B64TEST ] && [ "$INFILE" = "$2/$1" ] && { #  still the original input file?
   			base64 -d -w 0 $INFILE > $OUTFILE.tmp000 2>/dev/null # turns base64 into binary, saving 25%
   			if [ "$?" -eq 0 ]; then	# status of base64 when INFILE was entirely in base64
				INFILE="$OUTFILE".tmp000 # now this becomes the binary file to further compress
				KEYFILE="$KEYFILE".b64 # append .b64 extension for base64 origin
   			fi 
		}
	
		# regardless whether hexcheck or base64 tests succeeded or not, test general compression	
		$COMPRESSOR $FLAGS $INFILE > $OUTFILE.tmp001 
		local CMPS=$( stat -c%s $OUTFILE.tmp001 ) # the size after compression
		local ORGS=$( stat -c%s $INFILE )  # and before compression
		# use compressed version only if it is actually smaller
		if [ "$CMPS" -lt "$ORGS" ]; then 
			KEYFILE="$KEYFILE".$EXT # append compression extension to the keyfile to be generated
			INFILE="$OUTFILE".tmp001  # assign the compressed file name, else stay with previous
		fi
	}
	# generate and write out the key of the same size as the infile
	keygen $INFILE > $KEYFILE
	# encrypt with it and write to OUTFILE 
	symcrypt $INFILE $KEYFILE $OUTFILE
	rm $OUTFILE.tmp000 $OUTFILE.tmp001 2> /dev/null  #tidy up if needed
}

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {

	[ -z "$2" ] && { 
		printf "$PROGN quitting, keydir is not set!\n" >&2
		exit 2
	}
	[ -e "$2" ] && { 
		printf "$PROGN quitting, keydir $2 already exists!\n" >&2
		exit 2
	}
	[ -z "$3" ] && { 
		printf "$PROGN quitting, outdir is not set!\n" >&2
		exit 2
	}
	[ -e "$3" ] && { 
		printf "$PROGN quitting, outdir $3 already exists!\n" >&2
		exit 2
	}

	# create the ouput directories
	mkdir $2 $3
	[ "$?" -ne 0 ] && {
		printf "$PROGN quitting, failed to create output directories $2 $3!\n" >&2
		exit 2
	}

	# sort files in INDIR by size
	# stripping the path path prior to using ls was done thus: FILEND=${INFILE##*/} 
	ITEMS=$(ls -SAL $1)
	# prepare to fire off subshells
	BJ=\&

	# iterate through the listing
	for ITEM in $ITEMS; do
		local IND=$1/$ITEM
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				processdir $IND $2/$ITEM $3/$ITEM &
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] || continue # only process genuine file now
 		# turn off subshells when file size falls below BACKSZ
   		[ -z "$BJ" ] || [ $( stat -c%s $IND ) -ge $BACKSZ ] || BJ='' 
   		processfile $ITEM $1 $2 $3 $BJ 
	done
} # end of processdir

function usage { printf "Usage: $PROGN [-h][-b][-x][-q][-r][-v][-z] indir keydir outdir\n" >&2; }

# Main starts here
# get options, including long options, extracted as arg to the last option '-'
while getopts hbxqrvz-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
    h | help ) usage; printf "\t%s\n" \
		'-b | --b64 : test for base64 encoded files' \
		'-h | --help : print this text' \
		'-q | --quiet : turn off the final summary' \
		'-r | --recurse : process also subdirectories' \
		'-v | --verbose : detailed reporting' \
		'-x | --hex : test for hexadecimal files' \
		'-z | --zstd : use zstd compression instead of lzma' 
		exit 1;;
	# record all presented options
	b | b64 ) B64TEST=0;; 
	x | hex ) HEXTEST=0;;
	q | quiet ) QUIET=0;;
	v | verbose ) VERBOSE=0;; 
	r | recurse ) RECURSE=0;;
  	z | zstd ) COMPRESSOR=zstd; EXT=zst;; #alternative compressor and its extension
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

# Globally validate the input directory
[ -d "$1" ] || { 
	printf "$PROGN quitting, input directory $1 not found\n" >&2
	exit 2
}
# Globally validate the compressor. It has been set either to lzma or zstd
[ -z $( which "$COMPRESSOR" ) ] && { 
	printf "$PROGN quitting, compressor utility $COMPRESSOR not found\n" >&2
	exit 2
}
FLAGS='-c -z -q' # the default lags to the compressor
if [ $VERBOSE ]; then 
	if [ "$COMPRESSOR" = 'lzma' ]; then FLAGS='-c -z -v';	else FLAGS='-c'; fi
fi
printf "$PROGN encrypting and compressing, using %d cores\n" $( grep -c ^processor /proc/cpuinfo ) >&2
processdir $1 $2 $3
wait # for all sub proccesses to finish

# optional final report
if ! [ $QUIET ]; then
	SIZES=( $( du -hbs $3 $1 ) ) # array of size,dir,size,dir
	printf "$PROGN ${SIZES[3]}: ${SIZES[2]} => ${SIZES[1]}: ${SIZES[0]} "
	if [ ${SIZES[0]} = ${SIZES[2]} ]; then printf "(100 %%)\n"; else
		CR=$(( (5+100000*${SIZES[0]}/${SIZES[2]})/10 )) # calculate percentage rounded to two d.p.	
		printf "(${CR: 0:2}.${CR: 2:4} %%)\n" # compression ratio printed as xx.xx%
	fi 
	printf "$PROGN encrypted $1 into $3, keys written to $2\n"
fi
