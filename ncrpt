#!/bin/bash
# encrypts all files in the specified directory 'indir' 
# writes key files into directory 'keydir', extensions indicating compression methods 
# writes encrypted binary files with the same names into directory 'outdir' 

PROGN=${0##*/}
COMPRESSOR=lzma	# the default compression program
EXT=lz			# and the extension that goes with it
NOCOMPRESS=( 'jpg' 'jpeg' 'mp4' 'zip' '7z' 'lz' 'zst' 'gz' 'tgz' 'bz2' )

# function to compress and encrypt one file
# takes three arguments: INDIR KEYDIR OUTDIR
# KEYDIR OUTDIR must be writeable
# creates and cleans up two temporary files in OUTDIR
function processfile {

	local INFILE="$1"
	local KEYFILE="$2" 
	local OUTFILE="$3"
	local EX="${1##*.}" # this file's last extension
	local CH='u' # default uncompressed marker

	local EX=${EX,,} # convert to lower case, to detect both cases
	# if EX is on NOCOMPRESS list, then skip compression 
    for KEEPEXT in "${NOCOMPRESS[@]}"; do
        if [ "$EX" = "$KEEPEXT" ]; then
            keygen "$INFILE" > "$KEYFILE.u"
            symcrypt < "$INFILE" "$KEYFILE.u" > "$OUTFILE"
		    return
        fi
	done

    if [ $HEXTEST ] && hexcheck < "$INFILE" > "$OUTFILE".tmp 2>/dev/null; then 
		local CH='h' # hexadecimal compression enabled and detected
		local INFILE="$OUTFILE".tmp 
	else if [ $B64TEST ] &&	base64 -d -w 0 "$INFILE" > "$OUTFILE".tmp 2>/dev/null; then 
		local CH='b' # base64 compression enabled and detected 
		local INFILE="$OUTFILE".tmp 
		fi
	fi

	# regardless whether hexcheck or base64 tests succeeded or not, apply general compression test	
	$COMPRESSOR $FLAGS "$INFILE" > "$OUTFILE".cmp 
		local CMPS=$( stat -c%s "$OUTFILE".cmp ) # the size after compression
		local ORGS=$( stat -c%s "$INFILE" )  # and before compression
		# use compressed version only if it is actually smaller
		[ "$CMPS" -lt "$ORGS" ] && { # successful general compression
			local INFILE="$OUTFILE".cmp # make the final compressed file to be the infile
			if [ "$COMPRESSOR" = 'lzma' ]; then
			 case "$CH" in
			 u ) local CH='i';;
			 h ) local CH='j';;
			 b ) local CH='k';;
			 * ) printf "$PROGN processfile: unrecognised ch\n"
			 	 exit 2;;
			 esac
			else # compressor program is 'zstd'
			 case "$CH" in
			 u ) local CH='l';;
			 h ) local CH='m';;
			 b ) local CH='n';;
			 * ) printf "$PROGN processfile: unrecognised ch\n"
			 	 exit 2;;
			 esac
			fi				
		} # else no general compression gain, keep the original INFILE and codes: u,h,b
		
	# generate key of the same size as infile,
	# encrypt with it and write to OUTFILE.$CH 
	xorfork < "$INFILE" "$OUTFILE" > "$KEYFILE".$CH
	# clean up
	if [ -e "$OUTFILE.tmp" ]; then rm "$OUTFILE.tmp"; fi 
	if [ -e "$OUTFILE.cmp" ]; then rm "$OUTFILE.cmp"; fi 
} # end of processfile

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {

	# create the ouput directories
	mkdir "$2" "$3" || {
		printf "$PROGN quitting, failed to create output directories '$2' '$3'!\n" >&2
		exit 2
	}
	
    cd "$1"

	# iterate through the listing
	for ITEM in *; do 
        [[ "$ITEM" == '*' ]] && break; # no more  
   		if [ -d "$ITEM" ]; then  # directory
			[ -n "$IGNORE" ] && continue; 
			processdir "$ITEM" "../$2"/"$ITEM" "../$3"/"$ITEM" & # push ITEM onto paths
        else # process only genuine file
       		[ -f "$ITEM" ] && processfile "$ITEM" "../$2"/"$ITEM" "../$3"/"$ITEM" & 
        fi
	done
    cd ..
	wait
} # end of processdir

# function to update a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function updatedir {

	[ -d "$2" ] || {
		printf "$PROGN updatedir: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN updatedir: output dir $3 is invalid\n" >&2
		exit 2
	}

	# iterate through the listing checking for newer items
	for ITEM in $(ls -ALB $1); do
		local ID="$1"/"$ITEM" # append $ITEM to $INDIR path
		local OD=$3/$ITEM # and corresponding $outdir path

   		if [ -d "$ID" ]; then  # process existing subdirectory?
			[ -n "$IGNORE" ] && continue; # not recursing, ignore this subdir
			[ -d "$OD" ] || { # here matching dir does not exist
				printf " A: $ID\n" # so add it					
				processdir $ID $2/$ITEM $OD & # push ITEM onto paths 
				continue
			}
			# test the dirs modification times
			# note that -nt only works for additions/deletions to dirs			
			[ $(stat -c%Y $ID) -gt $(stat -c%Y "$OD") ] && { 
				printf " U: $ID\n" # so update it
				updatedir $ID $2/$ITEM $OD &
				continue
            }
			continue # up to date dir
		fi
   		[ -f "$ID" ] || continue; # ignore if not genuine file 
		[ -e "$OD" ] || { # $OD file does not exist
			printf "   a: $ID\n" # so add it
			processfile $ID $2/$ITEM $OD  
			continue
		}
		[ "$ID" -nt "$OD" ] && {  # here the input file is newer 
			printf "   u: $ID\n" # so update it
   			processfile $ID $2/$ITEM $OD  
        } # else just skip it
	done
	wait
} # end of updatedir

# function to clean up a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function cleandir {

	[ -d "$1" ] || {
		printf "$PROGN clean: input dir $1 is invalid\n" >&2
		exit 2
	}
	[ -d "$2" ] || {
		printf "$PROGN clean: key dir $2 is invalid\n" >&2
		exit 2
	}
	[ -d "$3" ] || {
		printf "$PROGN clean: output dir $3 is invalid\n" >&2
		exit 2
	}

	# iterate through the list checking for missing items
	for ITEM in $(ls -ALB $3); do
		local ID=$1/$ITEM # append $ITEM to $INDIR path
		local KD=$2/$ITEM # append $ITEM to $KEYDIR path
		local OD=$3/$ITEM # and the examined $OUTDIR path

   		if [ -d "$OD" ]; then  # process existing subdirectory?
			[ -n "$IGNORE" ] && continue; # not recursing, ignore this subdir 
			[ -d "$ID" ] || { # here matching $INDIR dir does not exist
				printf " D: $OD $KD\n" # so remove it 
				rm -rf "$OD" "$KD" &
				continue
			}			
			cleandir $ID $KD $OD &  # descend
		fi
   		[ -f "$OD" ] || continue; # only process genuine files now 
		[ -e "$ID" ] || { # here $ID file does not exist
			printf "   d: $OD $KD.*\n" # so delete them
			rm $OD $KD.* 
			continue
		}
	done
	wait
} # end of cleandir

function usage { printf "Usage: $PROGN -[b][c][h][q][r][u][v][x][z] indir keydir outdir\n" >&2; }

function helpmsg {
	usage
	printf "\t%s\n" \
		'-b | --b64 : test for base64 encoded files' \
		'-c | --cleanup : do deletions in the archive' \
		'-h | --help : print this text' \
        '-i | --ignore : ignore subdirectories' \
		'-q | --quiet : turn off the final summary' \
		'-u | --update : update' \
		'-v | --verbose : detailed reporting' \
		'-x | --hex : test for hexadecimal files' \
		'-z | --zstd : use zstd compression instead of lzma' >&2
	exit 1
}

# Main starts here ###########################################################
# get options, including long options, extracted as arg to the last option '-'
while getopts bchiquvxz-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
	b | b64 ) B64TEST=0;;
	c | clean ) CLEAN=0;; 
	h | help ) helpmsg;;
    i | ignore ) IGNORE=0;;
	q | quiet ) QUIET=0;;
	u | update ) UPDATE=0;;
	v | verbose ) VERBOSE=0;; 
	x | hex ) HEXTEST=0;;
  	z | zstd ) COMPRESSOR=zstd; EXT=zst;; #alternative compressor and its extension
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

# Validate the program arguments
[ "$#" -ne 3 ] && {
    printf "$PROGN expected three arguments, "$#" given!\n" >&2
    exit 2
}
# Validate the input directory
[ -d "$1" ] || { 
	printf "$PROGN quitting, input directory $1 not found\n" >&2
	exit 2
}
[ -e "$2" ] && { 
	printf "$PROGN processdir: keydir $2 already exists!\n" >&2
	exit 2
}
[ -e "$3" ] && { 
	printf "$PROGN processdir: outdir $3 already exists!\n" >&2
	exit 2
}

# Validate the compressor. It has been set either to lzma or zstd
[ -z $( which "$COMPRESSOR" ) ] && { 
	printf "$PROGN quitting, compressor utility $COMPRESSOR not found\n" >&2
	exit 2
}

FLAGS='-c -z -q' # the default lags to the compressor
if [ $VERBOSE ]; then 
	if [ "$COMPRESSOR" = 'lzma' ]; then FLAGS='-c -z -v';	else FLAGS='-c'; fi
fi

if [ $UPDATE ]; then 
	if [ $CLEAN ]; then 
		printf "$PROGN: cleaning up archive '$3', using %d cores\n" $( grep -c ^processor /proc/cpuinfo ) 
		cleandir $1 $2 $3
	fi
	printf "$PROGN: updating archive '$3', using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	updatedir $1 $2 $3
else
	printf "$PROGN: encrypting '$1', using %d cores\n" $( grep -c ^processor /proc/cpuinfo )
	processdir $1 $2 $3
fi

# optional final report
if ! [ $QUIET ]; then
	SIZES=( $( du -bs $3 $1 ) ) # array of size,dir,size,dir
	printf "$PROGN: ${SIZES[3]} ${SIZES[2]} => ${SIZES[1]} ${SIZES[0]} (%d%%)\n" \
		$(( 100*${SIZES[0]}/${SIZES[2]} )) # calculate percentage 
	printf "$PROGN: keys are in '$2'\n"
fi
