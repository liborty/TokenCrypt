#!/bin/bash
# decrypts all files in the specified directory 'dirname'
# using corresponding keys in the specified directory 'keysname'
# into corresponding original files in local directory 'dirname_org' 

BACKSZ=10000 # files above this size will be processed in subshells

PROGN=${0##*/}
case $# in
	0|1)
		printf "$PROGN quitting, needs keysdir encrypteddir\n" 
		exit 2;; 
	2)
      if ! [ -d "$1" ]; then
		printf "$PROGN quitting, keys directory $1 not found\n"
		exit 2; fi
		if ! [ -d "$2" ]; then
		printf "$PROGN quitting, encrypted directory $2 not found\n"
		exit 2; fi;;		
	*) 
		printf "$PROGN quitting, needs keysdir encrypteddir\n" 
		exit 2;;
esac

if [ -z $( which zstd ) ]; then 
	printf "$PROGN warning, zstd compressor is not installed, will not decompress .zstd files\n"
fi
if [ -z $( which lzma ) ]; then 
	printf "$PROGN warning, lzma compressor is not installed, will not decompress .lzma files\n"
fi
if [ -z $( which base64 ) ]; then 
	printf "$PROGN warning, base64 decoder is not installed, will not unpack .base64 files\n"
fi
if [ -z $( which hexify ) ]; then 
	printf "$PROGN warning, hexify is not installed, will not unpack .hex files\n"
fi

KEYDIR="$1"
INDIR="$2"
FAILED=0
OUTDIR=${2##*/} # just the last directory name, path is stripped off
# if the indir ending is standard _crp, then remove it from outdir
if [ "${OUTDIR##*_}" == 'crp' ]; then OUTDIR=${OUTDIR%_*}; fi
OUTDIR="$OUTDIR"_org # in any case append _org, i.e. original files reconstructed

# make output directory for all decrypted files
if [ -d "$OUTDIR" ]; then 
	printf "$PROGN quitting, '$OUTDIR' already exists here!\n"; exit 2
else mkdir $OUTDIR; fi

# define function to reconstruct one file, possibly in the background
function recoverfile {  
   	if [ -f $KEYFILE ]; then # found key with no extra extensions
		symcrypt $KEYFILE $INFILE $OUTFILE # just decrypt the infile and save it
		return
	fi
	if [ -f $KEYFILE.hex ]; then # found hex extension
		symcrypt $KEYFILE.hex $INFILE | hexify > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.b64 ]; then # found b64 extension
		symcrypt $KEYFILE.b64 $INFILE | base64 -w 0 > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.zst ]; then # found compressed plain
		symcrypt $KEYFILE.zst $INFILE | zstd -d -c > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.hex.zst ]; then # found hex and zst
		symcrypt $KEYFILE.hex.zst $INFILE | zstd -d -c | hexify > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.b64.zst ]; then # found b64 and zst
		symcrypt $KEYFILE.b64.zst $INFILE | zstd -d -c | base64 -w 0 > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.lz ]; then # found lzma compressed, plain
		symcrypt $KEYFILE.lz $INFILE | lzma -d > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.hex.lz ]; then # found hex and lz compressed
		symcrypt $KEYFILE.hex.lz $INFILE | lzma -d | hexify > $OUTFILE $BJ
		return
	fi
	if [ -f $KEYFILE.base64.lz ]; then # found b64 and lz compressed
		symcrypt $KEYFILE.b64.lz $INFILE | lzma -d | base64 -w 0 > $OUTFILE $BJ
		return
	fi
	printf "$PROGN failed to find a useful key for encrypted file $FNAME\n"
	let COUNT-=1
	let FAILED+=1
}

# sort files in INDIR by size
ITEMS=$(ls -SL $INDIR)
# prepare to fire off subshells
BJ=\&

# decompress all ITEMS, in decreasing order of size
for FNAME in $ITEMS; do
	INFILE=$INDIR/$FNAME	
   	[ -f "$INFILE" ] || continue # check that INFILE is a proper file
  	 # ${INFILE##*/} # original filename.extension without the preceding path
   	KEYFILE=$KEYDIR/$FNAME
   	OUTFILE=$OUTDIR/$FNAME
   	let COUNT+=1
	# turn off subshells when file size has fallen below BACKSZ
   	[ -z "$BJ" ] || [ $( stat -c%s $INFILE ) -ge $BACKSZ ] || BJ='' 
	recoverfile $BJ # BJ can be unset, then short files run in this shell
done
wait # to ensure that all backround recoverfiles have finished
printf "$PROGN: decrypted $COUNT files into $OUTDIR, $FAILED failures\n"
