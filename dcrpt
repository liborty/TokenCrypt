#!/bin/bash
# decrypts all files in the specified directory 'indir' 
# reads key files from directory 'keydir', extensions indicating compression methods 
# writes restored files with the same names into directory 'outdir' 

PROGN=${0##*/}
BACKSZ=10000 # size of files to be encrypted in the subshells

# function to decompress and decrypt one file
# takes four arguments: ITEM INDIR KEYDIR OUTDIR
# OUTDIR must be writeable
function processfile {

	local INFILE=$2/$1 
	local KEYFILE=$3/$1
	local OUTFILE=$4/$1 

   	if [ -f $KEYFILE ]; then # found key with no extra extensions
		symcrypt $KEYFILE $INFILE $OUTFILE # just decrypt the infile and save it
		return
	fi
	if [ -f $KEYFILE.hex ]; then # found hex extension
		symcrypt $KEYFILE.hex $INFILE | hexify > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.b64 ]; then # found b64 extension
		symcrypt $KEYFILE.b64 $INFILE | base64 -w 0 > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.zst ]; then # found compressed plain
		symcrypt $KEYFILE.zst $INFILE | zstd -d -c > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.hex.zst ]; then # found hex and zst
		symcrypt $KEYFILE.hex.zst $INFILE | zstd -d -c | hexify > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.b64.zst ]; then # found b64 and zst
		symcrypt $KEYFILE.b64.zst $INFILE | zstd -d -c | base64 -w 0 > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.lz ]; then # found lzma compressed, plain
		symcrypt $KEYFILE.lz $INFILE | lzma -d > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.hex.lz ]; then # found hex and lz compressed
		symcrypt $KEYFILE.hex.lz $INFILE | lzma -d | hexify > $OUTFILE
		return
	fi
	if [ -f $KEYFILE.base64.lz ]; then # found b64 and lz compressed
		symcrypt $KEYFILE.b64.lz $INFILE | lzma -d | base64 -w 0 > $OUTFILE
		return
	fi
	printf "$PROGN failed to find a useful key for encrypted file $INFILE\n" 
}

# function to process a whole directory
# takes three arguments: INDIR KEYDIR OUTDIR
function processdir {
	[ -n "$3" ] || { 
		printf "$PROGN quitting, outdir is not set!\n" >&2
		exit 2
	}
	[ -e "$3" ] && { 
		printf "$PROGN quitting, outdir $3 already exists!\n" >&2
		exit 2
	}
	# create the ouput directory
	mkdir $3
	[ "$?" -ne 0 ] && {
		printf "$PROGN quitting, failed to create output directory $3!\n" >&2
		exit 2
	}

	# sort files in INDIR by size
	# stripping the path path prior to using ls was done thus: FILEND=${INFILE##*/} 
	ITEMS=$(ls -SAL $1)
	# prepare to fire off subshells
	BJ=\&

	# iterate through the listing
	for ITEM in $ITEMS; do
		local IND=$1/$ITEM
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				processdir $IND $2/$ITEM $3/$ITEM &
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] || continue # only process genuine file now
 		# turn off subshells when file size falls below BACKSZ
   		[ -z "$BJ" ] || [ $( stat -c%s $IND ) -ge $BACKSZ ] || BJ='' 
   		processfile $ITEM $1 $2 $3 $BJ 
	done
} # end of processdir

function usage { printf "Usage: $PROGN [-h][-q][-r][-v] indir keydir outdir\n" >&2; }

# Main starts here
# get options, including long options, extracted as arg to the last option '-'
while getopts hqrv-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
    h | help ) usage; printf "\t%s\n" \
	'-h | --help : print this text' \
	'-q | --quiet : turn off the final summary' \
	'-r | --recurse : process also subdirectories' \
	'-v | --verbose : detailed reporting' 	
	exit 1;;
	# record all presented options
	q | quiet ) QUIET=0;;
	r | recurse ) RECURSE=0;;
	v | verbose ) VERBOSE=0;;  
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove already parsed options and args from $@ list

# Globally validate the input directory
[ -d "$1" ] || { 
	printf "$PROGN quitting, input directory $1 not found\n" >&2
	exit 2
}
# Globally validate the key directory
[ -d "$2" ] || { 
	printf "$PROGN quitting, key directory $2 not found\n" >&2
	exit 2
}
# Warn about missing decompressors
if [ -z $( which zstd ) ]; then 
	printf "$PROGN warning, zstd compressor is not installed, will not decompress .zst files\n"
fi
if [ -z $( which lzma ) ]; then 
	printf "$PROGN warning, lzma compressor is not installed, will not decompress .lz files\n"
fi
if [ -z $( which base64 ) ]; then 
	printf "$PROGN warning, base64 decoder is not installed, will not unpack .b64 files\n"
fi
if [ -z $( which hexify ) ]; then 
	printf "$PROGN warning, hexify is not installed, will not unpack .hex files\n"
fi

processdir $1 $2 $3
wait # for all sub proccesses to finish

# optional final report
if ! [ $QUIET ]; then
	SIZES=( $( du -hbs $3 $1 ) ) # array of size,dir,size,dir
	CR=$(( (5+100000*${SIZES[2]}/${SIZES[0]})/10 )) # calculate percentage rounded to two d.p.	
	printf "$PROGN ${SIZES[3]}: ${SIZES[2]} (${CR: 0:2}.${CR: 2:4} %%) => ${SIZES[1]}: ${SIZES[0]}\n"
	# compressed size x 10^5, printed as xx.xx% 
	printf "$PROGN decrypted $1 into $3\n"
fi
