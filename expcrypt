#!/bin/bash
# encrypts all files in the specified directory 'indir' 
# writes keys into file 'keyfile' 
# writes encrypted binary files with the same names into tarred 'outfile'

PROGN=${0##*/}
COMPRESSOR=lzma	# the default general compression program
NOCOMPRESS=( 'jpg' 'jpeg' 'mp4' 'zip' '7z' 'lz' 'zst' 'gz' 'tgz' 'bz2' )

# function to compress and encrypt one file
# takes two arguments: INFILE OUTFILE
# writes into OUTFILE and global KEYFILE
# creates and cleans up to two temporary files in OUTDIR
function processfile {

	local INFILE=$1 
	local OUTFILE=$2
	local EX="${1##*.}" # this file's last extension
	local CH='u' # default uncompressed marker

    local EX=${EX,,} # convert to lower case, to detect both cases
	# if EX is on NOCOMPRESS list, then skip compression 
    for KEEPEXT in "${NOCOMPRESS[@]}"; do
        if [ "$EX" = "$KEEPEXT" ]; then
		    printf 'u' >> $KEYFILE
            # creating temporary key file to avoid buffering sync problems         
            keygen $INFILE | tee -a $KEYFILE > $2key.tmp              
		    symcrypt < $INFILE $2key.tmp > $OUTFILE  
            rm $2key.tmp  
		    return
        fi
    done
	
    if [ $HEXTEST ] && hexcheck < $INFILE > $OUTFILE.tmp 2>/dev/null; then 
		CH='h' # hexadecimal compression enabled and detected
		INFILE=$OUTFILE.tmp 
	else if [ $B64TEST ] &&	base64 -d -w 0 $INFILE > $OUTFILE.tmp 2>/dev/null; then 
		CH='b'  # base64 compression enabled and detected
		INFILE=$OUTFILE.tmp 
		fi
	fi

	# regardless whether hexcheck or base64 tests succeeded or not, apply general compression test	
	$COMPRESSOR $FLAGS $INFILE > $OUTFILE.cmp 
		local CMPS=$( stat -c%s $OUTFILE.cmp ) # the size after compression
		local ORGS=$( stat -c%s $INFILE )  # and before compression
		# use compressed version only if it is actually smaller
		[ "$CMPS" -lt "$ORGS" ] && { # successful general compression
			INFILE=$OUTFILE.cmp # make the final compressed file to be the infile
			if [ "$COMPRESSOR" = 'lzma' ]; then
			 case "$CH" in
			 u ) CH='i';;
			 h ) CH='j';;
			 b ) CH='k';;
			 * ) printf "$PROGN processfile: unrecognised ch\n"; exit 2;;
			 esac
			else # compressor program is 'zstd'
			 case "$CH" in
			 u ) CH='l';;
			 h ) CH='m';;
			 b ) CH='n';;
			 * ) printf "$PROGN processfile: unrecognised ch\n"; exit 2;;
			 esac
			fi				
		} # else no general compression gain, keep the original INFILE and codes: u,h,b
		
	# write the prepared compression encoding byte to $KEYFILE
	printf "$CH" >> $KEYFILE
	# generate the key of the same size as infile,
	# append the key to the global linear keyfile,
	# encrypt with it and write to OUTFILE 
    keygen $INFILE | tee -a $KEYFILE > $2key.tmp 
    # creating temporary key file to avoid buffering sync problems             
	symcrypt < $INFILE $2key.tmp > $OUTFILE 
    # clean up 
    rm $2key.tmp
	if [ -e "$OUTFILE.tmp" ]; then rm $OUTFILE.tmp; fi 
	if [ -e "$OUTFILE.cmp" ]; then rm $OUTFILE.cmp; fi 
} # end of processfile

# function to process a whole directory
# takes two arguments: INDIR OUTDIR
function createdir {

	[ -e "$2" ] && { 
		printf "$PROGN createdir: outdir '$2' already exists!\n" >&2
		exit 2
	}

	# create the ouput directory
	mkdir $2 || {
		printf "$PROGN createdir: failed to create output directory '$2'!\n" >&2
		exit 2
	}

	# iterate through the listing
	for ITEM in $(ls -AL $1); do
		local IND=$1/$ITEM # append $ITEM to $INDIR path
   		if [ -d "$IND" ]; then  # recursively process existing subdirectory?
			if [ -n "$RECURSE" ]; then  # just push ITEM onto paths, no changing of directories
				createdir $IND $2/$ITEM 
			fi
			continue # either processed or ignored this subdir now
		fi
   		[ -f "$IND" ] && processfile $IND $2/$ITEM  
	done
} # end of createdir

function usage { printf "Usage: $PROGN [-h][-b][-x][-q][-r][-v][-z] indir keyfile outfile\n" >&2; }

function helpmsg {
	usage
	printf "\t%s\n" \
		'-b | --b64 : test for base64 encoded files' \
		'-h | --help : print this text' \
		'-q | --quiet : turn off the final summary' \
		'-r | --recurse : process also subdirectories' \
		'-v | --verbose : detailed reporting' \
		'-x | --hex : test for hexadecimal files' \
		'-z | --zstd : use zstd compression instead of lzma' >&2
	exit 1
}

# Main starts here ###########################################################
# get options, including long options, extracted as arg to the last option '-'
while getopts hbxqrvz-: OPT; do
 if [ "$OPT" = "-" ]; then   # long option: reset OPT and OPTARG
    OPT="${OPTARG%%=*}"      # extract long option name
    OPTARG="${OPTARG#$OPT}"  # extract long option argument (here empty)
    OPTARG="${OPTARG#=}"     # remove any assignments `=` from long options
 fi
 case "$OPT" in
	b | b64 ) B64TEST=0;;
	h | help ) helpmsg;;
	q | quiet ) QUIET=0;;
	r | recurse ) RECURSE=0;;
	v | verbose ) VERBOSE=0;; 
	x | hex ) HEXTEST=0;;
  	z | zstd ) COMPRESSOR=zstd;; #alternative compressor and its extension
    ??* ) printf "$PROGN quitting, invalid long option: $OPT\n" >&2; usage; exit 2;;  
	*) exit 2;;  # invalid short option (error will be reported via getopts)
 esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

# Globally validate the program arguments
[ -z "$1" ] && { 
	printf "$PROGN: the first argument (indir) is missing!\n" >&2
	exit 2
}
[ -d "$1" ] || { 
	printf "$PROGN: input directory '$1' not found!\n" >&2
	exit 2
}
[ -z "$2" ] && { 
	printf "$PROGN: the second argument (keyfile) is missing!\n" >&2
	exit 2
}
[ -e "$2" ] && {
	printf "$PROGN: keyfile '$2' already exists!\n" >&2
	exit 2
}
[ -z "$3" ] && { 
	printf "$PROGN: the third argument (outfile) is missing!\n" >&2
	exit 2
}
[ -e "$3" ] && {
	printf "$PROGN: outfile '$3' already exists!\n" >&2
	exit 2
}

# Globally validate the compressor. It has been set either to lzma or zstd
[ -z $( which "$COMPRESSOR" ) ] && { 
	printf "$PROGN quitting, compressor utility $COMPRESSOR not found\n" >&2
	exit 2
}

# check that tar exists
if [ -z $( which tar ) ]; then 
	printf "$PROGN: tar is not installed\n" >&2
	exit 2
fi

# Global options for the compressor
FLAGS='-c -z -q' 
if [ $VERBOSE ]; then 
	if [ "$COMPRESSOR" = 'lzma' ]; then FLAGS='-c -z -v';	else FLAGS='-c'; fi
fi

# Set verified global key file
KEYFILE=$2
# Create temporary OUTDIR, same root name as outfile
OUTDIR=$3dir 
printf "$PROGN: encrypting '$1' for export\n" 
createdir $1 $OUTDIR 
printf "Tarring into $3\n" 
tar -cJf $3 $OUTDIR
rm -rf $OUTDIR || {
	printf "$PROGN: failed to remove $OUTDIR\n" >&2
	exit 2
}

# optional final report
if [ ! $QUIET ]; then
	SIZES=( $( du -bs $3 $1 ) ) # array of size,dir,size,
	printf "$PROGN: ${SIZES[3]} ${SIZES[2]} => ${SIZES[1]} ${SIZES[0]} "
	if [ ${SIZES[0]} = ${SIZES[2]} ]; then 
		printf "(100 %%)\n"
	else
		CR=$(( (5+100000*${SIZES[0]}/${SIZES[2]})/10 )) # calculate percentage rounded to two d.p.	
		printf "(${CR: 0:2}.${CR: 2:4} %%)\n" # compression ratio printed as xx.xx%
	fi 
	printf "$PROGN: keys are in '$2'\n"
fi
